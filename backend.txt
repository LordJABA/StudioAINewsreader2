
#server.py contents
from flask import Flask, request, jsonify
from flask_cors import CORS
import newspaper
from dotenv import load_dotenv
import os
from functools import wraps

# Load environment variables from .env file
load_dotenv()

app = Flask(__name__)
# Enable CORS for all routes, allowing frontend to communicate with this backend
CORS(app)

# --- Security ---
# It's crucial to secure the backend to prevent unauthorized use.
# The secret key should be set as an environment variable on the server.
SECRET_KEY = os.environ.get('BACKEND_SECRET_KEY')

def require_secret_key(f):
    """A decorator to protect routes with a secret key."""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        # 1. Check if the secret key is configured on the server at all.
        if not SECRET_KEY:
            # This is a server configuration error.
            return jsonify({"error": "Backend secret key is not configured on the server."}), 500

        # 2. Check for the 'Authorization' header in the incoming request.
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({"error": "Missing or invalid Authorization header. Expected 'Bearer <key>'."}), 401

        # 3. Extract the key provided by the client.
        try:
            provided_key = auth_header.split(' ')[1]
        except IndexError:
            return jsonify({"error": "Malformed Authorization header."}), 401
        
        # 4. Compare the client's key with the server's secret key.
        if provided_key != SECRET_KEY:
            return jsonify({"error": "Invalid secret key."}), 403 # Forbidden

        # If all checks pass, proceed with the original function.
        return f(*args, **kwargs)
    return decorated_function

# --- Routes ---
@app.route('/fetch-source', methods=['GET'])
@require_secret_key # Apply the security decorator
def fetch_source_endpoint():
    """
    Crawls a news source URL, parses its recent articles, and returns them as a list.
    The URL is passed as a query parameter.
    e.g., /fetch-source?url=https://example.com/news
    """
    source_url = request.args.get('url')
    if not source_url:
        return jsonify({"error": "URL parameter is missing."}), 400 # Bad Request

    try:
        print(f"Building source for: {source_url}")
        source = newspaper.build(source_url, memoize_articles=False)
        
        articles_data = []
        # Limit to the first 10 articles to avoid long processing times and excessive traffic
        for article in source.articles[:10]:
            try:
                article.download()
                article.parse()
                if article.title and article.text:
                    articles_data.append({
                        "title": article.title,
                        "content": article.text,
                        "source": article.url
                    })
            except Exception as e:
                # Log and skip this individual article if it fails
                print(f"Could not process article {article.url}: {e}")
        
        if not articles_data:
            return jsonify({
                "error": "Could not find or parse any articles from the provided source URL."
            }), 422 # Unprocessable Entity

        return jsonify(articles_data)

    except Exception as e:
        # Catch any other exceptions during the build process
        print(f"Error building source at URL {source_url}: {e}")
        return jsonify({"error": f"An error occurred while processing the source URL: {str(e)}"}), 500


if __name__ == '__main__':
    # This block allows running the server directly for development.
    # For production, a WSGI server like Gunicorn should be used.
    # The host '0.0.0.0' makes the server accessible from any IP address.
    app.run(host='0.0.0.0', port=5000, debug=False)
